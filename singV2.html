<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Noten-Generator & Sänger-Check V3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

        .control-group {
            background-color: #f9fafb; /* gray-50 */
            padding: 1rem;
            border-radius: 0.5rem; /* rounded-lg */
            border: 1px solid #e5e7eb; /* gray-200 */
        }
        .control-group h3 {
            font-size: 1.125rem; /* text-lg */
            font-weight: 600; /* font-semibold */
            color: #4b5563; /* gray-600 */
            margin-bottom: 0.75rem;
        }
        .checkbox-label, .radio-label {
            display: flex;
            align-items: center;
            padding: 0.3rem 0;
            font-size: 0.95rem;
            color: #374151; /* gray-700 */
            cursor: pointer;
        }
        .checkbox-label input, .radio-label input {
            margin-right: 0.5rem;
            accent-color: #6366f1; /* indigo-500 */
        }
        .staff-container {
            margin-bottom: 10px;
        }
        .clickable-note:hover {
            cursor: pointer;
            opacity: 0.7;
        }
        .current-singing-note {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        #visualMetronomeIndicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #cbd5e1; /* Tailwind gray-300 */
            transition: background-color 0.1s ease-in-out;
            margin-top: 0.5rem;
        }
        #visualMetronomeIndicator.active {
            background-color: #fb7185; /* Tailwind rose-500 */
        }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-center min-h-screen p-4 py-8">

<div class="bg-white p-6 md:p-8 rounded-xl shadow-2xl w-full max-w-4xl"> <h1 class="text-3xl font-bold text-center text-indigo-600 mb-6">Noten-Generator & Sänger-Check</h1>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
        <div class="control-group">
            <h3>Erste Note (Melodie):</h3>
            <div id="startNoteOptions">
                <label class="radio-label"><input type="radio" name="startNote" value="random" checked> Zufällig</label>
                <label class="radio-label"><input type="radio" name="startNote" value="C2"> C2</label>
                <label class="radio-label"><input type="radio" name="startNote" value="C4"> C4</label>
            </div>
        </div>
        <div class="control-group">
            <h3>Erlaubte Intervalle (Melodie):</h3>
            <div id="intervalOptions" class="grid grid-cols-2 gap-x-4">
                <label class="checkbox-label"><input type="checkbox" name="interval" value="0" checked> Prime</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="1" checked> Sekunde</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="2" checked> Terz</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="3"> Quarte</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="4"> Quinte</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="5"> Sexte</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="6"> Septime</label>
                <label class="checkbox-label"><input type="checkbox" name="interval" value="7"> Oktave</label>
            </div>
        </div>
    </div>
    <div class="control-group mb-6">
        <div class="flex flex-col">
            <div class="flex items-center justify-center mb-4">
                <label class="checkbox-label mr-4"><input type="checkbox" id="visualMetronomeToggle"> Visueller Metronom</label>
                <div id="visualMetronomeIndicator"></div>
            </div>
            <div class="flex items-center justify-center">
                <label for="bpmInput" class="mr-2 font-medium text-gray-700">Tempo (BPM):</label>
                <input type="number" id="bpmInput" min="40" max="240" value="90" class="w-20 px-2 py-1 border border-gray-300 rounded-md text-center">
            </div>
        </div>
    </div>

    <div class="mb-3 staff-container overflow-x-auto">
        <h3 class="text-lg font-semibold text-gray-700 mb-1 text-center">Generierte Melodie (Klick auf Note zum Abspielen)</h3>
        <svg id="staffSvg" width="800" height="180" class="mx-auto bg-white border border-gray-300 rounded-lg shadow"></svg> </div>
    <div class="staff-container overflow-x-auto">
        <h3 class="text-lg font-semibold text-gray-700 mb-1 text-center">Aufgenommene Melodie</h3>
        <svg id="recordedStaffSvg" width="800" height="180" class="mx-auto bg-white border border-gray-300 rounded-lg shadow"></svg> </div>

    <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mt-6">
        <button id="generateNotesBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md">Neue Melodie</button>
        <button id="playNotesBtn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md">Melodie abspielen</button>
        <button id="recordBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md">Aufnahme starten</button>
        <button id="stopBtn" class="bg-gray-500 hover:bg-gray-600 text-white font-semibold py-3 px-6 rounded-lg shadow-md">Stopp</button>
    </div>
    <p id="messageBox" class="text-center mt-4 text-sm text-gray-700 min-h-[1.25em]"></p>
    <p id="detectedNoteDebug" class="text-center mt-2 text-xs text-gray-500 min-h-[1em]"></p>

    <div class="control-group mb-6 mt-6">
        <h3>Fortlaufende Notenerkennung:</h3>
        <div class="flex flex-col">
            <div class="flex items-center justify-between mb-2">
                <button id="continuousDetectionBtn" class="bg-purple-500 hover:bg-purple-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md">
                    Fortlaufende Notenerkennung starten
                </button>
                <span id="detectionStatus" class="text-sm text-gray-500">Inaktiv</span>
            </div>
            <div id="continuousDetectionResult" class="mt-2 p-3 border border-gray-300 rounded-md bg-gray-50 text-center min-h-[3rem]">
                <p id="detectedFrequency" class="text-lg font-bold text-purple-600">-</p>
                <p id="detectedNoteName" class="text-md text-gray-700">-</p>
            </div>
        </div>

    </div>
</div>
<script>
    console.log("Script loaded. Initializing...");
    // SVG Namespace
    const SVG_NS = "http://www.w3.org/2000/svg";

    // Konstanten
    const STAFF_MARGIN_TOP = 40;
    const STAFF_MARGIN_LEFT = 20;
    const LINE_SPACING = 15;
    const STAFF_LINES_COUNT = 5;
    const SVG_STAFF_WIDTH = 800; // Increased width
    const SVG_STAFF_HEIGHT = 180; // Increased height
    const NOTE_HEAD_RX = LINE_SPACING * 0.6;
    const NOTE_HEAD_RY = LINE_SPACING * 0.45;
    const STEM_LENGTH = LINE_SPACING * 3.5;
    const NOTE_STROKE_WIDTH = 1.5;
    const ACCIDENTAL_OFFSET_X = -NOTE_HEAD_RX * 1.8;
    const LINE_COLOR = "black";
    const NOTE_COLOR_DEFAULT = "black";
    const NOTE_COLOR_WRONG = "red";
    const NOTE_HIGHLIGHT_COLOR = "#4ade80"; // Green-400 from Tailwind
    const MIDDLE_LINE_D3_Y_GENERATED = STAFF_MARGIN_TOP + 2 * LINE_SPACING;
    const MIDDLE_LINE_D3_Y_RECORDED = STAFF_MARGIN_TOP + 2 * LINE_SPACING;

    const NOTE_PROPERTIES = {
        "C2": { scientific: "C2", yFactor: -8, midi: 36 }, "D2": { scientific: "D2", yFactor: -7, midi: 38 },
        "E2": { scientific: "E2", yFactor: -6, midi: 40 }, "F2": { scientific: "F2", yFactor: -5, midi: 41 },
        "G2": { scientific: "G2", yFactor: -4, midi: 43 }, "A2": { scientific: "A2", yFactor: -3, midi: 45 },
        "B2": { scientific: "B2", yFactor: -2, midi: 47 }, "C3": { scientific: "C3", yFactor: -1, midi: 48 },
        "D3": { scientific: "D3", yFactor: 0,  midi: 50 },  "E3": { scientific: "E3", yFactor: 1,  midi: 52 },
        "F3": { scientific: "F3", yFactor: 2,  midi: 53 },  "G3": { scientific: "G3", yFactor: 3,  midi: 55 },
        "A3": { scientific: "A3", yFactor: 4,  midi: 57 },  "B3": { scientific: "B3", yFactor: 5,  midi: 59 },
        "C4": { scientific: "C4", yFactor: 6,  midi: 60 }
    };
    const C_MAJOR_SCALE_NOTES_NAMES_ONLY = ["C", "D", "E", "F", "G", "A", "B"];
    const AVAILABLE_NOTES_SORTED = Object.keys(NOTE_PROPERTIES)
        .filter(key => C_MAJOR_SCALE_NOTES_NAMES_ONLY.includes(key.substring(0, key.length - 1)))
        .sort((a, b) => NOTE_PROPERTIES[a].midi - NOTE_PROPERTIES[b].midi);
    const noteStrings = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
    const solfegeMap = { "C": "do", "D": "re", "E": "mi", "F": "fa", "G": "sol", "A": "la", "B": "si" };

    // Globale Variablen
    let generatedNotes = [];
    let recordedNotesDisplay = [];
    let staffSvgElement = document.getElementById('staffSvg');
    let recordedStaffSvgElement = document.getElementById('recordedStaffSvg');
    let messageBox = document.getElementById('messageBox');
    let detectedNoteDebug = document.getElementById('detectedNoteDebug');
    let visualMetronomeToggle = document.getElementById('visualMetronomeToggle');
    let visualMetronomeIndicator = document.getElementById('visualMetronomeIndicator');
    let bpmInput = document.getElementById('bpmInput');

    let melodySynth, clickSynth;
    let audioContext, analyser, microphoneSourceNode;
    let pitchDetectionIntervalId = null;
    let visualMetronomeIntervalId = null;
    let isRecording = false;
    let currentRecordingSlot = 0;
    let detectedPitchesInSlot = [];
    let noteElementsArray = [];

    // For moving line animation
    let playbackLine = null;
    let animationFrameId = null;

    let isContinuousDetectionActive = false;
    let continuousDetectionIntervalId = null;
    let detectedFrequencyElement = document.getElementById('detectedFrequency');
    let detectedNoteNameElement = document.getElementById('detectedNoteName');
    let continuousDetectionBtn = document.getElementById('continuousDetectionBtn');
    let detectionStatusElement = document.getElementById('detectionStatus');

    try {
        melodySynth = new Tone.Synth().toDestination();
        clickSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 2, envelope: { attack: 0.001, decay: 0.3, sustain: 0, release: 0.1 }}).toDestination();
        clickSynth.volume.value = -10;
        console.log("Tone.js Synths initialized.");
    } catch (e) {
        console.error("Tone.js konnte nicht initialisiert werden:", e);
        messageBox.textContent = "Fehler: Audio-Engine.";
    }

    function getQuarterNoteDurationFromBPM() {
        const bpm = parseInt(bpmInput.value) || 90;
        return 60 / bpm;
    }

    // --- Pitch Detection ---
    function autoCorrelate(buffer, sampleRate) {
        var SIZE = buffer.length; var sumOfSquares = 0;
        for (var i = 0; i < SIZE; i++) { var val = buffer[i]; sumOfSquares += val * val; }
        var rootMeanSquare = Math.sqrt(sumOfSquares / SIZE);
        if (rootMeanSquare < 0.01) { return -1; }
        var r1 = 0, r2 = SIZE - 1, threshold = 0.2;
        for (var i = 0; i < SIZE / 2; i++) if (Math.abs(buffer[i]) < threshold) { r1 = i; break; }
        for (var i = 1; i < SIZE / 2; i++) if (Math.abs(buffer[SIZE - i]) < threshold) { r2 = SIZE - i; break; }
        buffer = buffer.slice(r1, r2); SIZE = buffer.length;
        if (SIZE === 0) return -1;
        var c = new Array(SIZE).fill(0);
        for (let i = 0; i < SIZE; i++) { for (let j = 0; j < SIZE - i; j++) { c[i] = c[i] + buffer[j] * buffer[j+i]; } }
        var d = 0; while (d < c.length - 1 && c[d] > c[d+1]) { d++; }
        if (d === c.length - 1 && c.length > 1) return -1;
        var maxValue = -1, maxIndex = -1;
        for (var i = d; i < SIZE; i++) { if (c[i] > maxValue) { maxValue = c[i]; maxIndex = i; } }
        var T0 = maxIndex;
        if (T0 === -1 || T0 === 0 || T0 + 1 >= c.length || T0 -1 < 0) return -1;
        var x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
        var a = (x1 + x3 - 2 * x2) / 2, b = (x3 - x1) / 2;
        if (a) { T0 = T0 - b / (2 * a); }
        return sampleRate/T0;
    }
    function noteFromPitch(frequency) {
        var noteNum = 12 * (Math.log(frequency / 440) / Math.log(2));
        return Math.round(noteNum) + 69;
    }
    function midiToNoteName(midiNum) {
        if (midiNum < 0 || midiNum > 127) return null;
        let octave = Math.floor(midiNum / 12) - 1;
        let noteName = noteStrings[midiNum % 12];
        return noteName + octave;
    }

    // --- SVG Helper Functions ---
    function createSvgElement(type, attributes) {
        const el = document.createElementNS(SVG_NS, type);
        for (const attr in attributes) { el.setAttribute(attr, attributes[attr]); }
        return el;
    }
    function drawStaffOnSvg(svgElement, middleLineY) {
        svgElement.innerHTML = '';
        for (let i = 0; i < STAFF_LINES_COUNT; i++) {
            const y = STAFF_MARGIN_TOP + i * LINE_SPACING;
            svgElement.appendChild(createSvgElement("line", { x1: STAFF_MARGIN_LEFT, y1: y, x2: SVG_STAFF_WIDTH - STAFF_MARGIN_LEFT, y2: y, stroke: LINE_COLOR, "stroke-width": "1" }));
        }
        const clefX = STAFF_MARGIN_LEFT + 25;
        const yF3Line = middleLineY - NOTE_PROPERTIES["F3"].yFactor * (LINE_SPACING / 2);
        const clefPath = createSvgElement("path", { d: `M ${clefX-5} ${yF3Line - LINE_SPACING*1.8} a ${LINE_SPACING*1.2} ${LINE_SPACING*1.2} 0 0 0 0 ${LINE_SPACING*3.6} c ${LINE_SPACING*0.8} ${LINE_SPACING*0.5} ${LINE_SPACING*1.5} ${-LINE_SPACING*0.5} ${LINE_SPACING*1.5} ${-LINE_SPACING*1.5} S ${clefX} ${yF3Line - LINE_SPACING*1.5} ${clefX-5} ${yF3Line - LINE_SPACING*1.8}`, fill: "none", stroke: NOTE_COLOR_DEFAULT, "stroke-width": "2.5" });
        svgElement.appendChild(clefPath);
        const dotRadius = LINE_SPACING * 0.2;
        const yG3Space = middleLineY - NOTE_PROPERTIES["G3"].yFactor * (LINE_SPACING / 2);
        const yE3Space = middleLineY - NOTE_PROPERTIES["E3"].yFactor * (LINE_SPACING / 2);
        svgElement.appendChild(createSvgElement("circle", { cx: clefX + LINE_SPACING * 1.1, cy: yG3Space, r: dotRadius, fill: NOTE_COLOR_DEFAULT }));
        svgElement.appendChild(createSvgElement("circle", { cx: clefX + LINE_SPACING * 1.1, cy: yE3Space, r: dotRadius, fill: NOTE_COLOR_DEFAULT }));
    }
    function getNoteDrawingParams(scientificNoteName) {
        let notePart = scientificNoteName.slice(0, -1);
        let octave = parseInt(scientificNoteName.slice(-1));
        let baseNoteName = notePart[0];
        let accidental = notePart.length > 1 ? notePart.substring(1) : "";
        let diatonicBaseKey = baseNoteName + octave;
        let noteInfo = NOTE_PROPERTIES[diatonicBaseKey];
        if (!noteInfo) {
            console.warn(`Keine direkte Note für ${scientificNoteName} in NOTE_PROPERTIES. Fallback-Versuch...`);
            const tempMidi = noteStrings.indexOf(notePart) + (octave + 1) * 12;
            if(tempMidi !== -1 && !isNaN(tempMidi)) {
                let closestDiatonicKey = null;
                let minDiff = Infinity;
                for (const key in NOTE_PROPERTIES) {
                    const diff = Math.abs(NOTE_PROPERTIES[key].midi - tempMidi);
                    if (diff < minDiff) { minDiff = diff; closestDiatonicKey = key;
                    } else if (diff === minDiff) {
                        if (NOTE_PROPERTIES[key].scientific.startsWith(baseNoteName)) { closestDiatonicKey = key; }
                    }
                }
                if (closestDiatonicKey) {
                    noteInfo = NOTE_PROPERTIES[closestDiatonicKey];
                    console.log(`Fallback für ${scientificNoteName}: Nutze ${closestDiatonicKey} (yFactor: ${noteInfo.yFactor}) als Basis.`);
                } else { console.error(`Fallback fehlgeschlagen für ${scientificNoteName}. MIDI: ${tempMidi}`); return null; }
            } else { console.error(`Konnte MIDI für ${scientificNoteName} nicht bestimmen.`); return null; }
        }
        return { yFactor: noteInfo.yFactor, accidental: accidental };
    }
    function drawNoteOnSvg(svgElement, middleLineY, noteData, xPosition, noteColor = NOTE_COLOR_DEFAULT, isClickable = false, noteIndex = null) {
        const drawingParams = getNoteDrawingParams(noteData.scientific);
        if (!drawingParams) { console.warn("Zeichnen abgebrochen, Parameter nicht gefunden für:", noteData.scientific); return null; }
        const { yFactor, accidental } = drawingParams;
        const cy = middleLineY - yFactor * (LINE_SPACING / 2);
        drawLedgerLinesOnSvg(svgElement, middleLineY, xPosition, cy, yFactor);

        const noteGroup = createSvgElement("g");
        if (isClickable) {
            noteGroup.classList.add("clickable-note");
            noteGroup.setAttribute("data-note-scientific", noteData.scientific);
            noteGroup.setAttribute("data-note-duration", noteData.duration);
            if (noteIndex !== null) noteGroup.setAttribute("data-note-index", noteIndex);
        }

        const noteHead = createSvgElement("ellipse", { cx: xPosition, cy: cy, rx: NOTE_HEAD_RX, ry: NOTE_HEAD_RY, fill: noteData.duration === "2n" && noteColor === NOTE_COLOR_DEFAULT ? "white" : noteColor, stroke: noteColor, "stroke-width": NOTE_STROKE_WIDTH });
        noteGroup.appendChild(noteHead);

        if (accidental) {
            const accidentalSymbol = accidental === "#" ? "♯" : (accidental === "b" ? "♭" : "");
            const accidentalText = createSvgElement("text", { x: xPosition + ACCIDENTAL_OFFSET_X, y: cy + NOTE_HEAD_RY / 2, "font-size": `${LINE_SPACING * 1.5}px`, fill: noteColor, "font-family": "Arial Unicode MS, Lucida Sans Unicode, DejaVu Sans, sans-serif" });
            accidentalText.textContent = accidentalSymbol;
            noteGroup.appendChild(accidentalText);
        }
        let stemX = xPosition; let stemY1 = cy; let stemY2;
        if (yFactor < 0) { stemX = xPosition + NOTE_HEAD_RX * 0.85; stemY2 = cy - STEM_LENGTH; }
        else { stemX = xPosition - NOTE_HEAD_RX * 0.85; stemY2 = cy + STEM_LENGTH; }
        const stem = createSvgElement("line", { x1: stemX, y1: stemY1, x2: stemX, y2: stemY2, stroke: noteColor, "stroke-width": "1.5" });
        noteGroup.appendChild(stem);

        const noteLetter = noteData.scientific.slice(0, 1);
        const solfegeLabel = solfegeMap[noteLetter] || '';
        if (solfegeLabel) {
            const labelText = createSvgElement("text", {
                x: xPosition,
                y: STAFF_MARGIN_TOP + STAFF_LINES_COUNT * LINE_SPACING + 25, // Position below staff
                "font-size": "14px",
                "font-weight": "500",
                fill: noteColor,
                "text-anchor": "middle"
            });
            labelText.textContent = solfegeLabel;
            noteGroup.appendChild(labelText);
        }

        svgElement.appendChild(noteGroup);
        return noteGroup;
    }
    function drawLedgerLinesOnSvg(svgElement, middleLineY, cx, noteCy, yFactor) {
        const ledgerWidth = NOTE_HEAD_RX * 2.5; const x1 = cx - ledgerWidth / 2; const x2 = cx + ledgerWidth / 2; const step = LINE_SPACING / 2;
        if (yFactor <= -8) {
            svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (-8 * step), x2, y2: middleLineY - (-8 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
            svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (-6 * step), x2, y2: middleLineY - (-6 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
            if (yFactor <= -10) svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (-10 * step), x2, y2: middleLineY - (-10 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
        } else if (yFactor === -7 || yFactor === -6) {
            svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (-6 * step), x2, y2: middleLineY - (-6 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
        }
        if (yFactor >= 6) {
            svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (6 * step), x2, y2: middleLineY - (6 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
            if (yFactor >= 8) svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (8 * step), x2, y2: middleLineY - (8 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
            if (yFactor >= 10) svgElement.appendChild(createSvgElement("line", { x1, y1: middleLineY - (10 * step), x2, y2: middleLineY - (10 * step), stroke: LINE_COLOR, "stroke-width": "1" }));
        }
    }
    function highlightCurrentNote(index) {
        noteElementsArray.forEach(noteEl => {
            if (noteEl) {
                noteEl.classList.remove('current-singing-note');
                const ellipse = noteEl.querySelector('ellipse');
                if (ellipse) {
                    const isDotted = ellipse.getAttribute('fill') === 'white';
                    ellipse.setAttribute('fill', isDotted ? 'white' : NOTE_COLOR_DEFAULT);
                    ellipse.setAttribute('stroke', NOTE_COLOR_DEFAULT);
                }
            }
        });

        if (index >= 0 && index < noteElementsArray.length && noteElementsArray[index]) {
            noteElementsArray[index].classList.add('current-singing-note');
            const ellipse = noteElementsArray[index].querySelector('ellipse');
            if (ellipse) {
                const isDotted = ellipse.getAttribute('fill') === 'white';
                ellipse.setAttribute('stroke', NOTE_HIGHLIGHT_COLOR);
                if (!isDotted) {
                    ellipse.setAttribute('fill', NOTE_HIGHLIGHT_COLOR);
                }
            }
        }
    }
    function removePlaybackLine() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
        }
        if (playbackLine) {
            playbackLine.remove();
            playbackLine = null;
        }
    }

    // --- Core Logic ---
    function generateAndDisplayNotes() {
        console.log("generateAndDisplayNotes called");
        stopAllAudioAndRecording();
        messageBox.textContent = '';
        drawStaffOnSvg(staffSvgElement, MIDDLE_LINE_D3_Y_GENERATED);
        drawStaffOnSvg(recordedStaffSvgElement, MIDDLE_LINE_D3_Y_RECORDED);
        recordedNotesDisplay = [];
        generatedNotes = [];
        noteElementsArray = [];

        const startNoteOption = document.querySelector('input[name="startNote"]:checked').value;
        const selectedIntervalSteps = Array.from(document.querySelectorAll('input[name="interval"]:checked')).map(cb => parseInt(cb.value));
        if (selectedIntervalSteps.length === 0) { messageBox.textContent = "Bitte Intervall(e) auswählen."; return; }

        let currentNoteScientific;
        if (startNoteOption === "C2") currentNoteScientific = "C2";
        else if (startNoteOption === "C4") currentNoteScientific = "C4";
        else currentNoteScientific = AVAILABLE_NOTES_SORTED[Math.floor(Math.random() * AVAILABLE_NOTES_SORTED.length)];
        if (!AVAILABLE_NOTES_SORTED.includes(currentNoteScientific)) currentNoteScientific = AVAILABLE_NOTES_SORTED[0];
        generatedNotes.push({ scientific: currentNoteScientific, duration: Math.random() < 0.5 ? "4n" : "2n" });

        for (let i = 0; i < 6; i++) {
            let currentNoteIndex = AVAILABLE_NOTES_SORTED.indexOf(currentNoteScientific);
            let nextNoteScientific = null; let attempts = 0;
            while (!nextNoteScientific && attempts < 50) {
                const randomIntervalStep = selectedIntervalSteps[Math.floor(Math.random() * selectedIntervalSteps.length)];
                const direction = Math.random() < 0.5 ? 1 : -1;
                let nextNoteIndex = currentNoteIndex + (randomIntervalStep * direction);
                if (nextNoteIndex >= 0 && nextNoteIndex < AVAILABLE_NOTES_SORTED.length) { nextNoteScientific = AVAILABLE_NOTES_SORTED[nextNoteIndex]; }
                else {
                    nextNoteIndex = currentNoteIndex + (randomIntervalStep * -direction);
                    if (nextNoteIndex >= 0 && nextNoteIndex < AVAILABLE_NOTES_SORTED.length) { nextNoteScientific = AVAILABLE_NOTES_SORTED[nextNoteIndex]; }
                }
                attempts++;
            }
            if (!nextNoteScientific) nextNoteScientific = AVAILABLE_NOTES_SORTED[Math.floor(Math.random() * AVAILABLE_NOTES_SORTED.length)];
            currentNoteScientific = nextNoteScientific;
            generatedNotes.push({ scientific: currentNoteScientific, duration: Math.random() < 0.3 ? "2n" : "4n" });
        }
        console.log("Generierte Noten:", JSON.parse(JSON.stringify(generatedNotes)));

        const availableWidth = SVG_STAFF_WIDTH - (STAFF_MARGIN_LEFT + 100) - STAFF_MARGIN_LEFT;
        const totalDurationUnits = generatedNotes.reduce((sum, note) => sum + (note.duration === "2n" ? 2 : 1), 0);
        const widthPerUnit = totalDurationUnits > 0 ? availableWidth / totalDurationUnits : 0;


        let currentX = STAFF_MARGIN_LEFT + 100;
        generatedNotes.forEach((note, index) => {
            const noteWidth = (note.duration === "2n" ? 2 : 1) * widthPerUnit;
            const noteXPosition = currentX;
            note.xPosition = noteXPosition; // Store x position for moving line

            const noteElement = drawNoteOnSvg(staffSvgElement, MIDDLE_LINE_D3_Y_GENERATED, note, noteXPosition, NOTE_COLOR_DEFAULT, true, index);
            noteElementsArray.push(noteElement);
            currentX += noteWidth;
        });
        messageBox.textContent = "Neue Melodie generiert.";
    }

    async function playMelodyOnly(isCountInOnly = false) {
        console.log(`playMelodyOnly called. isCountInOnly: ${isCountInOnly}`);
        if (!isCountInOnly && !generatedNotes.length) { messageBox.textContent = "Erst Melodie generieren."; return; }

        if (!isCountInOnly) stopAllAudioAndRecording();
        if (!melodySynth || !clickSynth) { messageBox.textContent = "Audio-Engine Fehler."; return; }

        try {
            if (Tone.context.state !== 'running') await Tone.start();
            const now = Tone.now();
            let accumulatedTime = 0;
            const quarterNoteDuration = getQuarterNoteDurationFromBPM();

            messageBox.textContent = "Einzähler...";
            for (let i = 0; i < 4; i++) {
                clickSynth.triggerAttackRelease("C5", "16n", now + accumulatedTime);
                if (visualMetronomeToggle.checked) {
                    Tone.Draw.schedule(() => visualMetronomeIndicator.classList.add("active"), now + accumulatedTime);
                    Tone.Draw.schedule(() => visualMetronomeIndicator.classList.remove("active"), now + accumulatedTime + quarterNoteDuration * 0.5);
                }
                accumulatedTime += quarterNoteDuration;
            }

            if (isCountInOnly) {
                setTimeout(() => {
                    if (visualMetronomeToggle.checked) visualMetronomeIndicator.classList.remove("active");
                    if (messageBox.textContent === "Einzähler...") messageBox.textContent = "Bereit für Aufnahme.";
                }, accumulatedTime * 1000 + 100);
                return accumulatedTime; // Return count-in duration
            }

            const countInEndPlaybackTime = accumulatedTime;
            accumulatedTime += quarterNoteDuration * 0.25;

            messageBox.textContent = "Spiele Melodie...";
            generatedNotes.forEach((note) => {
                const noteDurationInSeconds = (note.duration === "2n" ? 2 : 1) * quarterNoteDuration;
                melodySynth.triggerAttackRelease(note.scientific, noteDurationInSeconds, now + accumulatedTime);

                if (visualMetronomeToggle.checked) {
                    for (let beatTime = 0; beatTime < noteDurationInSeconds; beatTime += quarterNoteDuration) {
                        if (now + accumulatedTime + beatTime >= countInEndPlaybackTime) {
                            Tone.Draw.schedule(() => visualMetronomeIndicator.classList.add("active"), now + accumulatedTime + beatTime);
                            Tone.Draw.schedule(() => visualMetronomeIndicator.classList.remove("active"), now + accumulatedTime + beatTime + quarterNoteDuration * 0.5);
                        }
                    }
                }
                accumulatedTime += noteDurationInSeconds;
            });

            setTimeout(() => {
                if (messageBox.textContent.startsWith("Spiele") || messageBox.textContent.startsWith("Einzähler")) messageBox.textContent = '';
                if (visualMetronomeToggle.checked) visualMetronomeIndicator.classList.remove("active");
            }, accumulatedTime * 1000 + 500);

        } catch (error) { console.error("Fehler beim Abspielen:", error); messageBox.textContent = "Abspielfehler."; }
    }

    async function initAudioRecording() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { alert('Mikrofonzugriff nicht unterstützt.'); return false; }
        if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
        if (audioContext.state === 'suspended') await audioContext.resume();

        analyser = audioContext.createAnalyser();
        analyser.minDecibels = -100; analyser.maxDecibels = -10;
        analyser.smoothingTimeConstant = 0.7; analyser.fftSize = 2048;

        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            microphoneSourceNode = audioContext.createMediaStreamSource(stream);
            microphoneSourceNode.connect(analyser);
            return true;
        } catch (err) { alert('Mikrofonzugriff verweigert.'); console.error("getUserMedia error:", err); return false; }
    }
    function processAudioSlot() {
        if (!isRecording || !analyser) return;
        const buffer = new Float32Array(analyser.fftSize);
        analyser.getFloatTimeDomainData(buffer);
        const fundamentalFrequency = autoCorrelate(buffer, audioContext.sampleRate);
        if (fundamentalFrequency !== -1) detectedPitchesInSlot.push(fundamentalFrequency);
    }
    function analyzeAndStoreSlotPitch() {
        if (detectedPitchesInSlot.length > 0) {
            const midiNotesInSlot = detectedPitchesInSlot.map(f => noteFromPitch(f)).filter(n => n !== null && n >= 0 && n <= 127);
            if (midiNotesInSlot.length > 0) {
                midiNotesInSlot.sort((a,b) => a-b);
                const medianMidi = midiNotesInSlot[Math.floor(midiNotesInSlot.length / 2)];
                const sungNoteScientific = midiToNoteName(medianMidi);
                if (sungNoteScientific) {
                    const generatedNote = generatedNotes[currentRecordingSlot];
                    const color = (NOTE_PROPERTIES[generatedNote.scientific]?.midi === medianMidi) ? NOTE_COLOR_DEFAULT : NOTE_COLOR_WRONG;
                    recordedNotesDisplay.push({ scientific: sungNoteScientific, duration: generatedNote.duration, color: color });
                    detectedNoteDebug.textContent = `Slot ${currentRecordingSlot+1}: ${sungNoteScientific} (${(color === NOTE_COLOR_WRONG ? "Abweichung" : "Korrekt")})`;
                } else { recordedNotesDisplay.push(null); detectedNoteDebug.textContent = `Slot ${currentRecordingSlot+1}: Stille`; }
            } else { recordedNotesDisplay.push(null); detectedNoteDebug.textContent = `Slot ${currentRecordingSlot+1}: Stille`; }
        } else { recordedNotesDisplay.push(null); detectedNoteDebug.textContent = `Slot ${currentRecordingSlot+1}: Stille`; }
        detectedPitchesInSlot = [];
    }

    async function startRecordingProcess() {
        console.log("startRecordingProcess called");
        if (isRecording) { console.log("Aufnahme läuft bereits."); return; }
        if (!generatedNotes.length || !generatedNotes[0].xPosition) { messageBox.textContent = "Erst Melodie generieren."; return; }

        stopAllAudioAndRecording();
        const audioReady = await initAudioRecording();
        if (!audioReady) { console.error("Audio Aufnahme nicht bereit."); return; }

        isRecording = true;
        currentRecordingSlot = 0;
        recordedNotesDisplay = [];
        detectedPitchesInSlot = [];
        drawStaffOnSvg(recordedStaffSvgElement, MIDDLE_LINE_D3_Y_RECORDED);

        const staffTop = STAFF_MARGIN_TOP - LINE_SPACING;
        const staffBottom = STAFF_MARGIN_TOP + (STAFF_LINES_COUNT - 1) * LINE_SPACING + LINE_SPACING;
        const startX = generatedNotes[0].xPosition;
        playbackLine = createSvgElement("line", { x1: startX, y1: staffTop, x2: startX, y2: staffBottom, stroke: "#ef4444", "stroke-width": "2.5" });
        staffSvgElement.appendChild(playbackLine);
        highlightCurrentNote(0);

        const countInDurationSeconds = await playMelodyOnly(true);
        if (typeof countInDurationSeconds !== 'number') { console.error("Fehler beim Einzähler."); isRecording = false; removePlaybackLine(); return; }

        setTimeout(() => {
            if (!isRecording) { removePlaybackLine(); return; }
            const quarterNoteDuration = getQuarterNoteDurationFromBPM();
            const totalMelodyDurationMs = generatedNotes.reduce((sum, note) => sum + (note.duration === "2n" ? 2 : 1) * quarterNoteDuration, 0) * 1000;
            const startX = generatedNotes[0].xPosition;
            const endX = generatedNotes[generatedNotes.length - 1].xPosition;
            const travelDistance = endX - startX > 0 ? endX - startX : 1;
            let startTime = null;
            function animateLine(timestamp) {
                if (!isRecording) return;
                if (!startTime) startTime = timestamp;
                const elapsedTime = timestamp - startTime;
                const progress = Math.min(elapsedTime / totalMelodyDurationMs, 1);
                const newX = startX + progress * travelDistance;
                playbackLine.setAttribute("x1", newX);
                playbackLine.setAttribute("x2", newX);
                if (progress < 1) animationFrameId = requestAnimationFrame(animateLine);
                else removePlaybackLine();
            }
            animationFrameId = requestAnimationFrame(animateLine);
        }, countInDurationSeconds * 1000);

        messageBox.textContent = `Aufnahme läuft... (Note 1/${generatedNotes.length})`;
        pitchDetectionIntervalId = setInterval(processAudioSlot, 60);

        let slotStartTime = countInDurationSeconds;
        const quarterNoteDuration = getQuarterNoteDurationFromBPM();

        for (let i = 0; i < generatedNotes.length; i++) {
            const noteDurationSeconds = (generatedNotes[i].duration === "2n" ? 2 : 1) * quarterNoteDuration;
            const slotEndTime = slotStartTime + noteDurationSeconds;

            if (visualMetronomeToggle.checked) {
                for (let beat = 0; beat < noteDurationSeconds; beat += quarterNoteDuration) {
                    Tone.Draw.schedule(() => visualMetronomeIndicator.classList.add("active"), Tone.now() + slotStartTime + beat);
                    Tone.Draw.schedule(() => visualMetronomeIndicator.classList.remove("active"), Tone.now() + slotStartTime + beat + quarterNoteDuration * 0.5);
                }
            }

            Tone.Draw.schedule(() => highlightCurrentNote(i), Tone.now() + slotStartTime);

            setTimeout(() => {
                if (!isRecording) return;
                analyzeAndStoreSlotPitch();
                currentRecordingSlot++;
                if (currentRecordingSlot < generatedNotes.length) {
                    messageBox.textContent = `Aufnahme läuft... (Note ${currentRecordingSlot + 1}/${generatedNotes.length})`;
                    highlightCurrentNote(currentRecordingSlot);
                }
            }, slotEndTime * 1000 - 50);

            slotStartTime = slotEndTime;
        }
        setTimeout(() => { if(isRecording) stopRecordingAndDisplay(); }, slotStartTime * 1000 + 200);
    }

    function stopRecordingAndDisplay() {
        if (!isRecording && !pitchDetectionIntervalId) return;
        isRecording = false;
        if (pitchDetectionIntervalId) { clearInterval(pitchDetectionIntervalId); pitchDetectionIntervalId = null; }
        if (visualMetronomeIntervalId) { clearInterval(visualMetronomeIntervalId); visualMetronomeIntervalId = null; visualMetronomeIndicator.classList.remove("active"); }
        Tone.Transport.cancel();
        clickSynth.triggerRelease(); melodySynth.triggerRelease();
        highlightCurrentNote(-1);
        removePlaybackLine();
        if (microphoneSourceNode) {
            microphoneSourceNode.disconnect();
            microphoneSourceNode.mediaStream?.getTracks().forEach(track => track.stop());
            microphoneSourceNode = null;
        }

        messageBox.textContent = "Aufnahme beendet. Ergebnisse werden angezeigt.";
        detectedNoteDebug.textContent = "";

        drawStaffOnSvg(recordedStaffSvgElement, MIDDLE_LINE_D3_Y_RECORDED);

        const availableWidth = SVG_STAFF_WIDTH - (STAFF_MARGIN_LEFT + 100) - STAFF_MARGIN_LEFT;
        const totalDurationUnits = generatedNotes.reduce((sum, note) => sum + (note.duration === "2n" ? 2 : 1), 0);
        const widthPerUnit = totalDurationUnits > 0 ? availableWidth / totalDurationUnits : 0;
        let currentX = STAFF_MARGIN_LEFT + 100;

        for(let i=0; i < recordedNotesDisplay.length; i++) {
            const recordedNote = recordedNotesDisplay[i];
            const originalNote = generatedNotes[i];
            const noteWidth = (originalNote.duration === "2n" ? 2 : 1) * widthPerUnit;
            const noteXPosition = currentX;

            if (recordedNote) {
                const displayNoteData = { ...recordedNote, duration: originalNote.duration };
                drawNoteOnSvg(recordedStaffSvgElement, MIDDLE_LINE_D3_Y_RECORDED, displayNoteData, noteXPosition, recordedNote.color);
            }
            currentX += noteWidth;
        }
    }

    function stopAllAudioAndRecording() {
        console.log("stopAllAudioAndRecording called");
        Tone.Transport.stop(); Tone.Transport.cancel();
        melodySynth?.triggerRelease(); clickSynth?.triggerRelease();
        highlightCurrentNote(-1);
        removePlaybackLine();

        if (isRecording) {
            isRecording = false;
            if (pitchDetectionIntervalId) { clearInterval(pitchDetectionIntervalId); pitchDetectionIntervalId = null; }
            if (microphoneSourceNode) {
                microphoneSourceNode.disconnect();
                microphoneSourceNode.mediaStream?.getTracks().forEach(track => track.stop());
                microphoneSourceNode = null;
            }
        }
        if (visualMetronomeIntervalId) { clearInterval(visualMetronomeIntervalId); visualMetronomeIntervalId = null; }
        visualMetronomeIndicator.classList.remove("active");
        if (isContinuousDetectionActive) stopContinuousDetection();

        messageBox.textContent = "Alle Vorgänge gestoppt.";
        detectedNoteDebug.textContent = "";
    }

    async function toggleContinuousDetection() {
        if (isContinuousDetectionActive) stopContinuousDetection();
        else await startContinuousDetection();
    }
    async function startContinuousDetection() {
        stopAllAudioAndRecording();
        const audioReady = await initAudioRecording();
        if (!audioReady) return;

        isContinuousDetectionActive = true;
        continuousDetectionBtn.textContent = "Fortlaufende Notenerkennung stoppen";
        continuousDetectionBtn.classList.remove("bg-purple-500", "hover:bg-purple-600");
        continuousDetectionBtn.classList.add("bg-red-500", "hover:bg-red-600");
        detectionStatusElement.textContent = "Aktiv";
        detectionStatusElement.classList.add("text-green-500");
        continuousDetectionIntervalId = setInterval(detectAndDisplayCurrentNote, 100);
    }
    function stopContinuousDetection() {
        if (continuousDetectionIntervalId) { clearInterval(continuousDetectionIntervalId); continuousDetectionIntervalId = null; }
        if (microphoneSourceNode) {
            microphoneSourceNode.disconnect();
            microphoneSourceNode.mediaStream?.getTracks().forEach(track => track.stop());
            microphoneSourceNode = null;
        }
        isContinuousDetectionActive = false;
        continuousDetectionBtn.textContent = "Fortlaufende Notenerkennung starten";
        continuousDetectionBtn.classList.remove("bg-red-500", "hover:bg-red-600");
        continuousDetectionBtn.classList.add("bg-purple-500", "hover:bg-purple-600");
        detectionStatusElement.textContent = "Inaktiv";
        detectionStatusElement.classList.remove("text-green-500");
        detectedFrequencyElement.textContent = "-";
        detectedNoteNameElement.textContent = "-";
    }
    function detectAndDisplayCurrentNote() {
        if (!analyser) return;
        const buffer = new Float32Array(analyser.fftSize);
        analyser.getFloatTimeDomainData(buffer);
        const frequency = autoCorrelate(buffer, audioContext.sampleRate);
        if (frequency !== -1) {
            detectedFrequencyElement.textContent = `${frequency.toFixed(1)} Hz`;
            const midiNote = noteFromPitch(frequency);
            const noteName = midiToNoteName(midiNote);
            if (noteName) detectedNoteNameElement.textContent = `${noteName} (MIDI: ${midiNote})`;
            else detectedNoteNameElement.textContent = `Unbekannte Note (MIDI: ${midiNote})`;
        } else {
            detectedFrequencyElement.textContent = "Keine Frequenz erkannt";
            detectedNoteNameElement.textContent = "-";
        }
    }

    // --- Event Listeners ---
    bpmInput.addEventListener('change', () => {
        let value = parseInt(bpmInput.value);
        if (isNaN(value) || value < 40) bpmInput.value = 40;
        else if (value > 240) bpmInput.value = 240;
    });

    document.getElementById('generateNotesBtn').addEventListener('click', generateAndDisplayNotes);
    document.getElementById('playNotesBtn').addEventListener('click', () => playMelodyOnly(false));
    document.getElementById('recordBtn').addEventListener('click', startRecordingProcess);
    document.getElementById('stopBtn').addEventListener('click', stopAllAudioAndRecording);

    staffSvgElement.addEventListener('click', async (event) => {
        const clickedGroup = event.target.closest('.clickable-note');
        if (clickedGroup) {
            const noteSci = clickedGroup.dataset.noteScientific;
            const noteDur = clickedGroup.dataset.noteDuration || "4n";
            if (noteSci && melodySynth) {
                if (Tone.context.state !== 'running') await Tone.start();
                melodySynth.triggerAttackRelease(noteSci, noteDur, Tone.now());
            }
        }
    });

    continuousDetectionBtn.addEventListener('click', toggleContinuousDetection);

    // Initialisierung
    drawStaffOnSvg(staffSvgElement, MIDDLE_LINE_D3_Y_GENERATED);
    drawStaffOnSvg(recordedStaffSvgElement, MIDDLE_LINE_D3_Y_RECORDED);
    generateAndDisplayNotes();
    messageBox.textContent = "Bereit. Generieren Sie eine Melodie oder starten Sie direkt.";
    console.log("Initialisierung abgeschlossen.");
</script>
</body>
</html>